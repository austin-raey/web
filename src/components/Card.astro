---
interface Props {
	class?: string;
}

const { class: className } = Astro.props;
---

<astro-card
	class="block aspect-[2.125/3.375] max-w-[302px] sm:aspect-[3.375/2.125] sm:max-w-[30rem]"
>
	<div class="rotator size-full overflow-hidden rounded-xl p-5 shadow-2xl">
		<div
			aria-hidden="true"
			class="shine pointer-events-none absolute left-0 top-0 z-30 size-full opacity-25"
		>
		</div>
		<img
			alt=""
			aria-hidden="true"
			class="pointer-events-none absolute left-0 top-0 z-20 block size-full object-cover opacity-15 mix-blend-multiply"
			loading="eager"
			src="/bg/texture.avif"
		/>
		<img
			alt=""
			aria-hidden="true"
			class="pointer-events-none absolute left-0 top-0 z-0 block size-full object-cover opacity-25 blur-sm brightness-75 contrast-125 saturate-150"
			loading="eager"
			src="/bg/1.avif"
		/>
		<div class:list={["relative z-10", className]}>
			<slot />
		</div>
	</div>
	<div class="back layer-1 absolute left-0 top-0 -z-10 size-full rounded-xl">
	</div>
	<div class="back layer-2 absolute left-0 top-0 -z-20 size-full rounded-xl">
	</div>
</astro-card>

<script>
	// Define the behaviour for our new type of HTML element.
	class AstroCard extends HTMLElement {
		constructor() {
			super();
		}

		#onPointerLeave() {
			// Reset the card's rotation when the pointer leaves the card.
			requestAnimationFrame(() => {
				this.style.setProperty("--rotate-x", "0deg");
				this.style.setProperty("--rotate-y", "0deg");
			});

			// slowly transition the shine back to the center of the card.
			requestAnimationFrame(() => {
				this.style.setProperty("--pointer-x", `${this.offsetWidth / 2}px`);
				this.style.setProperty("--pointer-y", `${this.offsetHeight / 2}px`);
			});
		}

		#onPointerMove(event: PointerEvent) {
			const cursorPosX = event.clientX - this.offsetLeft;
			const cursorPosY = event.clientY - this.offsetTop;

			// Calculate the rotation of the card based on the pointer's position.
			const x = (cursorPosX - this.offsetWidth / 2) / 15;
			const y = (cursorPosY - this.offsetHeight / 2) / 15;

			// Update the CSS custom properties to rotate the card.
			requestAnimationFrame(() => {
				this.style.setProperty("--rotate-x", `${-x}deg`);
				this.style.setProperty("--rotate-y", `${y}deg`);
				this.style.setProperty("--pointer-x", `${cursorPosX}px`);
				this.style.setProperty("--pointer-y", `${cursorPosY}px`);
			});
		}

		connectedCallback() {
			this.addEventListener("pointermove", this.#onPointerMove);
			this.addEventListener("pointerleave", this.#onPointerLeave);
		}

		disconnectedCallback() {
			this.removeEventListener("pointermove", this.#onPointerMove);
			this.removeEventListener("pointerleave", this.#onPointerLeave);
		}
	}

	// Tell the browser to use our AstroHeart class for <astro-heart> elements.
	customElements.define("astro-card", AstroCard);
</script>

<style>
	:root {
		--pointer-x: 0px;
		--pointer-y: 0px;
		--rotate-x: 0deg;
		--rotate-y: 0deg;
		--translate-x: 0px;
		--translate-y: 0px;
	}

	astro-card .back {
		background: linear-gradient(
			180deg,
			hsla(0, 0%, 90%, 0.45),
			hsla(0, 0%, 90%, 0.5)
		);
		transform-origin: center;
		transform-style: preserve-3d;
		transform: rotateY(var(--rotate-x)) rotateX(var(--rotate-y))
			translateZ(-10px);
	}

	astro-card .back.layer-2 {
		transform: rotateY(var(--rotate-x)) rotateX(var(--rotate-y))
			translateZ(-20px);
	}

	astro-card .rotator {
		transform-origin: center;
		transform-style: preserve-3d;
		transform: rotateY(var(--rotate-x)) rotateX(var(--rotate-y));
	}

	astro-card {
		perspective: 900px;
		transform-origin: center;
		transform: translate3d(var(--translate-x), var(--translate-y), 0);
	}

	astro-card .shine {
		background-image: radial-gradient(
			farthest-corner circle at var(--pointer-x) var(--pointer-y),
			hsla(50, 20%, 90%, 0.45) 0%,
			hsla(150, 20%, 30%, 0.45) 100%,
			hsla(0, 0%, 0%, 0.9) 175%
		);
		filter: brightness(0.9) contrast(2);
		mix-blend-mode: overlay;
		transition: opacity 0.1s ease-in-out;
	}
</style>
